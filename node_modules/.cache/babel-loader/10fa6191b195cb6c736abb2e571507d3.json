{"ast":null,"code":"export function bind(f) {\n  let args = Array.prototype.slice.call(arguments, 1);\n  return function () {\n    return f.apply(null, args);\n  };\n}\nexport function copyObj(obj, target, overwrite) {\n  if (!target) target = {};\n\n  for (let prop in obj) if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) target[prop] = obj[prop];\n\n  return target;\n} // Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\n\nexport function countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n\n  for (let i = startIndex || 0, n = startValue || 0;;) {\n    let nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end) return n + (end - i);\n    n += nextTab - i;\n    n += tabSize - n % tabSize;\n    i = nextTab + 1;\n  }\n}\nexport class Delayed {\n  constructor() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  }\n\n  onTimeout(self) {\n    self.id = 0;\n\n    if (self.time <= +new Date()) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date());\n    }\n  }\n\n  set(ms, f) {\n    this.f = f;\n    const time = +new Date() + ms;\n\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  }\n\n}\nexport function indexOf(array, elt) {\n  for (let i = 0; i < array.length; ++i) if (array[i] == elt) return i;\n\n  return -1;\n} // Number of pixels added to scroller and sizer to hide scrollbar\n\nexport let scrollerGap = 50; // Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\n\nexport let Pass = {\n  toString: function () {\n    return \"CodeMirror.Pass\";\n  }\n}; // Reused option objects for setSelection & friends\n\nexport let sel_dontScroll = {\n  scroll: false\n},\n    sel_mouse = {\n  origin: \"*mouse\"\n},\n    sel_move = {\n  origin: \"+move\"\n}; // The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\n\nexport function findColumn(string, goal, tabSize) {\n  for (let pos = 0, col = 0;;) {\n    let nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) nextTab = string.length;\n    let skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal) return pos + Math.min(skipped, goal - col);\n    col += nextTab - pos;\n    col += tabSize - col % tabSize;\n    pos = nextTab + 1;\n    if (col >= goal) return pos;\n  }\n}\nlet spaceStrs = [\"\"];\nexport function spaceStr(n) {\n  while (spaceStrs.length <= n) spaceStrs.push(lst(spaceStrs) + \" \");\n\n  return spaceStrs[n];\n}\nexport function lst(arr) {\n  return arr[arr.length - 1];\n}\nexport function map(array, f) {\n  let out = [];\n\n  for (let i = 0; i < array.length; i++) out[i] = f(array[i], i);\n\n  return out;\n}\nexport function insertSorted(array, value, score) {\n  let pos = 0,\n      priority = score(value);\n\n  while (pos < array.length && score(array[pos]) <= priority) pos++;\n\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nexport function createObj(base, props) {\n  let inst;\n\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n\n  if (props) copyObj(props, inst);\n  return inst;\n}\nlet nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nexport function isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n}\nexport function isWordChar(ch, helper) {\n  if (!helper) return isWordCharBasic(ch);\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n  return helper.test(ch);\n}\nexport function isEmpty(obj) {\n  for (let n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\n  return true;\n} // Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\n\nlet extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nexport function isExtendingChar(ch) {\n  return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n} // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n\nexport function skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) pos += dir;\n\n  return pos;\n} // Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to`\n// satisfies `pred`. Supports `from` being greater than `to`.\n\nexport function findFirst(pred, from, to) {\n  // At any point we are certain `to` satisfies `pred`, don't know\n  // whether `from` does.\n  let dir = from > to ? -1 : 1;\n\n  for (;;) {\n    if (from == to) return from;\n    let midF = (from + to) / 2,\n        mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n    if (mid == from) return pred(mid) ? from : to;\n    if (pred(mid)) to = mid;else from = mid + dir;\n  }\n}","map":{"version":3,"sources":["E:/Internship Project/deploy/codebix/node_modules/codemirror/src/util/misc.js"],"names":["bind","f","args","Array","prototype","slice","call","arguments","apply","copyObj","obj","target","overwrite","prop","hasOwnProperty","countColumn","string","end","tabSize","startIndex","startValue","search","length","i","n","nextTab","indexOf","Delayed","constructor","id","time","handler","onTimeout","self","Date","setTimeout","set","ms","clearTimeout","array","elt","scrollerGap","Pass","toString","sel_dontScroll","scroll","sel_mouse","origin","sel_move","findColumn","goal","pos","col","skipped","Math","min","spaceStrs","spaceStr","push","lst","arr","map","out","insertSorted","value","score","priority","splice","nothing","createObj","base","props","inst","Object","create","nonASCIISingleCaseWordChar","isWordCharBasic","ch","test","toUpperCase","toLowerCase","isWordChar","helper","source","isEmpty","extendingChars","isExtendingChar","charCodeAt","skipExtendingChars","str","dir","charAt","findFirst","pred","from","to","midF","mid","ceil","floor"],"mappings":"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","sourcesContent":["export function bind(f) {\n  let args = Array.prototype.slice.call(arguments, 1)\n  return function(){return f.apply(null, args)}\n}\n\nexport function copyObj(obj, target, overwrite) {\n  if (!target) target = {}\n  for (let prop in obj)\n    if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      target[prop] = obj[prop]\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nexport function countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/)\n    if (end == -1) end = string.length\n  }\n  for (let i = startIndex || 0, n = startValue || 0;;) {\n    let nextTab = string.indexOf(\"\\t\", i)\n    if (nextTab < 0 || nextTab >= end)\n      return n + (end - i)\n    n += nextTab - i\n    n += tabSize - (n % tabSize)\n    i = nextTab + 1\n  }\n}\n\nexport class Delayed {\n  constructor() {\n    this.id = null\n    this.f = null\n    this.time = 0\n    this.handler = bind(this.onTimeout, this)\n  }\n  onTimeout(self) {\n    self.id = 0\n    if (self.time <= +new Date) {\n      self.f()\n    } else {\n      setTimeout(self.handler, self.time - +new Date)\n    }\n  }\n  set(ms, f) {\n    this.f = f\n    const time = +new Date + ms\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id)\n      this.id = setTimeout(this.handler, ms)\n      this.time = time\n    }\n  }\n}\n\nexport function indexOf(array, elt) {\n  for (let i = 0; i < array.length; ++i)\n    if (array[i] == elt) return i\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nexport let scrollerGap = 50\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nexport let Pass = {toString: function(){return \"CodeMirror.Pass\"}}\n\n// Reused option objects for setSelection & friends\nexport let sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"}\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nexport function findColumn(string, goal, tabSize) {\n  for (let pos = 0, col = 0;;) {\n    let nextTab = string.indexOf(\"\\t\", pos)\n    if (nextTab == -1) nextTab = string.length\n    let skipped = nextTab - pos\n    if (nextTab == string.length || col + skipped >= goal)\n      return pos + Math.min(skipped, goal - col)\n    col += nextTab - pos\n    col += tabSize - (col % tabSize)\n    pos = nextTab + 1\n    if (col >= goal) return pos\n  }\n}\n\nlet spaceStrs = [\"\"]\nexport function spaceStr(n) {\n  while (spaceStrs.length <= n)\n    spaceStrs.push(lst(spaceStrs) + \" \")\n  return spaceStrs[n]\n}\n\nexport function lst(arr) { return arr[arr.length-1] }\n\nexport function map(array, f) {\n  let out = []\n  for (let i = 0; i < array.length; i++) out[i] = f(array[i], i)\n  return out\n}\n\nexport function insertSorted(array, value, score) {\n  let pos = 0, priority = score(value)\n  while (pos < array.length && score(array[pos]) <= priority) pos++\n  array.splice(pos, 0, value)\n}\n\nfunction nothing() {}\n\nexport function createObj(base, props) {\n  let inst\n  if (Object.create) {\n    inst = Object.create(base)\n  } else {\n    nothing.prototype = base\n    inst = new nothing()\n  }\n  if (props) copyObj(props, inst)\n  return inst\n}\n\nlet nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/\nexport function isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nexport function isWordChar(ch, helper) {\n  if (!helper) return isWordCharBasic(ch)\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true\n  return helper.test(ch)\n}\n\nexport function isEmpty(obj) {\n  for (let n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nlet extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/\nexport function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nexport function skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) pos += dir\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to`\n// satisfies `pred`. Supports `from` being greater than `to`.\nexport function findFirst(pred, from, to) {\n  // At any point we are certain `to` satisfies `pred`, don't know\n  // whether `from` does.\n  let dir = from > to ? -1 : 1\n  for (;;) {\n    if (from == to) return from\n    let midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF)\n    if (mid == from) return pred(mid) ? from : to\n    if (pred(mid)) to = mid\n    else from = mid + dir\n  }\n}\n"]},"metadata":{},"sourceType":"module"}